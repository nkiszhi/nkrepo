import sys
from pathlib import Path

# Add project root to path for imports
PROJECT_ROOT = Path(__file__).resolve().parent.parent.parent
sys.path.insert(0, str(PROJECT_ROOT))

from flask import Flask, request, send_from_directory, jsonify
from flask_cors import CORS
import numpy as np
import json
import os
import pymysql
import subprocess
import logging
import re

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Import configuration from config.py
from config import (
    Config,
    HOST_IP, PORT, ROW_PER_PAGE,
    SAMPLE_REPO, ZIP_STORAGE, UPLOAD_FOLDER,
    DB_CATEGORY as db1, DB_FAMILY as db2, DB_PLATFORM as db3,
    VT_API_KEY as api_key
)

# Import from reorganized modules
from db.db_operations import DatabaseOperation
#from multi_scan.dga_detection import DGADetection
#from multi_scan.file_detect import EXEDetection
#from multi_scan.ensemble_predict import run_ensemble_prediction
from api_vt import VirusTotalAPI

db_ops = DatabaseOperation()
vt_api = VirusTotalAPI()
#dga_detector = DGADetection()

app = Flask(__name__)
CORS(app)

# =============================================================================
# Helper Functions
# =============================================================================

def api_success(data, message="Success"):
    """Return standardized success response."""
    return jsonify({"code": 20000, "data": data, "message": message})

def api_error(message, code=50000, http_status=500):
    """Return standardized error response."""
    return jsonify({"code": code, "data": None, "message": message}), http_status

def validate_sha256(sha256):
    """Validate SHA256 hash format (64 hex characters)."""
    if not sha256 or not re.match(r'^[a-fA-F0-9]{64}$', sha256):
        return False
    return True

def convert_to_serializable(obj):
    """Convert NumPy types to Python native types for JSON serialization."""
    if isinstance(obj, np.ndarray):
        return obj.tolist()
    if isinstance(obj, (np.int64, np.float64, np.int32, np.float32)):
        return obj.item()
    if isinstance(obj, dict):
        return {k: convert_to_serializable(v) for k, v in obj.items()}
    if isinstance(obj, (list, tuple)):
        return [convert_to_serializable(i) for i in obj]
    return obj

def build_sample_dict(query_result):
    """Build standardized sample dictionary from database query result."""
    return {
        'MD5': query_result[1],
        'SHA256': query_result[2],
        'category': query_result[5],
        'platform': query_result[6],
        'family': query_result[7],
        'file_extension': query_result[10],
        'unpacked': query_result[11],
        'SSDEEP': query_result[12]
    }

# Database mapping for query types
DB_MAPPING = {
    'category': (db1, 'category_'),
    'family': (db2, 'family_'),
    'platform': (db3, 'platform_')
}

# =============================================================================
# Domain Detection (DGA)
# =============================================================================

@app.route('/api/detect', methods=['POST'])
def detect_domain():
    """Detect if a domain is generated by DGA (Domain Generation Algorithm)."""
    return
    try:
        data = request.json
        if not data:
            return api_error("Request body is required", code=40000, http_status=400)

        url = data.get('url')
        if url is None:
            return api_error("URL is required", code=40000, http_status=400)

        result = dga_detector.multi_predict_single_dname(url)
        if isinstance(result, tuple) and len(result) == 2:
            result_dict, status_code = result
            result_dict = convert_to_serializable(result_dict)
            logger.info(f"DGA detection result for {url}: {result_dict}")

            return api_success({
                'status': '1' if status_code else '0',
                'result': result_dict
            })
        else:
            logger.error(f"Unexpected result format from DGA detector: {result}")
            return api_error("Unexpected result format from DGA detector")

    except Exception as e:
        logger.error(f"Error in domain detection: {str(e)}")
        return api_error(f"Domain detection failed: {str(e)}")

# =============================================================================
# File Upload and Detection
# =============================================================================

# Upload folder is configured in config.py
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER

# 确保上传文件夹存在
if not os.path.exists(app.config['UPLOAD_FOLDER']):
    os.makedirs(app.config['UPLOAD_FOLDER'])

@app.route('/upload', methods=['POST'])
def upload_file():
    """Upload a file for malware detection analysis."""
    try:
        if 'file' not in request.files:
            return api_error("No file part in request", code=40000, http_status=400)

        receive_file = request.files['file']
        if receive_file.filename == '':
            return api_error("No file selected", code=40000, http_status=400)

        original_filename = receive_file.filename
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], original_filename)
        receive_file.save(file_path)
        logger.info(f"File uploaded: {original_filename}")

        file_size_bytes = os.path.getsize(file_path)
        file_size_kb = file_size_bytes / 1024
        file_size = format(file_size_kb, '.2f') + " KB"

        #exe_result = run_ensemble_prediction(file_path)
        #exe_result = convert_to_serializable(exe_result)
        exe_result = []

        query_result = db_ops.filesha256(original_filename)
        query_result = convert_to_serializable(query_result)

        if len(query_result) == 2:
            query_result_inner = query_result[0]
            query_result_dict = {
                'MD5': query_result_inner[1],
                'SHA256': query_result_inner[2],
                'category': query_result_inner[5],
                'platform': query_result_inner[6],
                'family': query_result_inner[7]
            }
            VT_API = query_result[1]
        else:
            query_result_dict = {
                'MD5': query_result[1],
                'SHA256': query_result[0]
            }
            VT_API = query_result[2]

        return api_success({
            'original_filename': original_filename,
            'query_result': query_result_dict,
            'file_size': file_size,
            'exe_result': exe_result,
            'VT_API': VT_API
        })

    except Exception as e:
        logger.error(f"Error uploading file: {str(e)}")
        return api_error(f"File upload failed: {str(e)}")


@app.route('/uploads/<filename>')
def uploaded_file(filename):
    """Serve uploaded files."""
    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)


# =============================================================================
# VirusTotal API Endpoints
# =============================================================================

@app.route('/detection_API/<sha256>')
def get_detection_API(sha256):
    """Get VirusTotal detection results for a sample."""
    try:
        if not validate_sha256(sha256):
            return api_error("Invalid SHA256 hash format", code=40000, http_status=400)

        sample_dir_path = str(Config.get_sample_dir(sha256))
        json_file_path = vt_api.get_API_result_detection(sha256, api_key, sample_dir_path)
        logger.info(f"Detection API result path: {json_file_path}")

        if json_file_path == 500:
            return api_error("Failed to fetch VirusTotal detection results")

        db_ops.update_db(sha256)

        with open(json_file_path, 'r') as file:
            scan_result = json.load(file)

        if 'data' not in scan_result or 'attributes' not in scan_result['data']:
            return api_error("Missing required data in VirusTotal response", code=40000, http_status=400)

        attributes = scan_result['data']['attributes']
        if 'last_analysis_results' in attributes:
            last_analysis_results = attributes['last_analysis_results']
        else:
            last_analysis_results = attributes.get('results', {})

        results = []
        for engine in last_analysis_results.values():
            results.append({
                "method": engine.get('method'),
                "engine_name": engine.get('engine_name'),
                "engine_version": engine.get('engine_version'),
                "engine_update": engine.get('engine_update'),
                "category": engine.get('category'),
                "result": engine.get('result')
            })

        return api_success(results)

    except FileNotFoundError:
        logger.error(f"Detection result file not found for {sha256}")
        return api_error("Detection result file not found", code=40400, http_status=404)
    except json.JSONDecodeError as e:
        logger.error(f"Error decoding detection JSON: {str(e)}")
        return api_error("Error decoding detection results")
    except Exception as e:
        logger.error(f"Error in detection API: {str(e)}")
        return api_error(f"Detection API failed: {str(e)}")


@app.route('/behaviour_API/<sha256>')
def get_behaviour_API(sha256):
    """Get VirusTotal behaviour analysis results for a sample."""
    try:
        if not validate_sha256(sha256):
            return api_error("Invalid SHA256 hash format", code=40000, http_status=400)

        sample_dir_path = str(Config.get_sample_dir(sha256))
        behaviour_file_path = vt_api.get_API_result_behaviour(sha256, api_key, sample_dir_path)
        logger.info(f"Behaviour API result path: {behaviour_file_path}")

        with open(behaviour_file_path, 'r') as file:
            behaviour_scan = json.load(file)
            behaviour_data = behaviour_scan.get('data', {})
            logger.info(f"Behaviour data retrieved for {sha256}")
            return api_success(behaviour_data)

    except FileNotFoundError:
        logger.error(f"Behaviour file not found for {sha256}")
        return api_error("Behaviour file not found", code=40400, http_status=404)
    except json.JSONDecodeError as e:
        logger.error(f"Error decoding behaviour JSON: {str(e)}")
        return api_error("Error decoding behaviour results", code=40000, http_status=400)
    except Exception as e:
        logger.error(f"Error in behaviour API: {str(e)}")
        return api_error(f"Behaviour API failed: {str(e)}")


# =============================================================================
# File Download Utilities
# =============================================================================

def get_file_path_and_zip(sha256, zip_password="infected"):
    # Build file path using Config utility
    file_path = str(Config.get_sample_path(sha256))
    # Build ZIP file path using Config utility
    zip_file_path = str(Config.get_zip_path(sha256))  
  
    # 检查原始文件是否存在  
    if os.path.exists(file_path):  
        # 检查ZIP文件是否已存在  
        if os.path.exists(zip_file_path):  
            # 如果ZIP文件已存在，直接返回ZIP文件路径  
            return zip_file_path  
        else:  
            # 如果ZIP文件不存在，则使用7z命令创建它  
            # 确保ZIP文件所在的目录存在  
            os.makedirs(os.path.dirname(zip_file_path), exist_ok=True)  
  
            # Use 7z command to create encrypted ZIP file
            # Check for 7z or 7za (Linux alternative)
            zip_cmd = None
            for cmd in ['7z', '7za']:
                try:
                    subprocess.run([cmd, '--help'], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, check=True)
                    zip_cmd = cmd
                    break
                except (subprocess.CalledProcessError, FileNotFoundError):
                    continue

            if zip_cmd is None:
                raise FileNotFoundError("7zip is not installed. On Ubuntu: sudo apt install p7zip-full")

            command = [
                zip_cmd, 'a', '-tzip', '-p{}'.format(zip_password),
                zip_file_path, file_path
            ]
            subprocess.run(command, check=True)  
  
            # 返回新创建的ZIP文件路径  
            return zip_file_path  
    else:  
        # 如果原始文件不存在，则返回None  
        return None


# =============================================================================
# Unified Query, Detail, and Download Endpoints
# =============================================================================

@app.route('/query/<search_type>', methods=['POST'])
def query_virus(search_type):
    """
    Unified query endpoint for category, family, and platform searches.

    Args:
        search_type: One of 'category', 'family', or 'platform'

    Request body:
        {"tableName": "trojan"}  # The specific type/family/platform to search
    """
    try:
        if search_type not in DB_MAPPING:
            return api_error(
                f"Invalid search type: {search_type}. Must be one of: category, family, platform",
                code=40000,
                http_status=400
            )

        data = request.json
        if not data:
            return api_error("Request body is required", code=40000, http_status=400)

        table_name = data.get('tableName')
        if not table_name:
            return api_error("tableName is required", code=40000, http_status=400)

        database, prefix = DB_MAPPING[search_type]
        full_table_name = prefix + table_name

        sha256s = db_ops.mysql(full_table_name, database)
        if sha256s != 0:
            return api_success({'sha256s': sha256s})
        else:
            return api_error(f"No samples found for {search_type}: {table_name}", code=40400, http_status=404)

    except Exception as e:
        logger.error(f"Error in query/{search_type}: {str(e)}")
        return api_error(f"Query failed: {str(e)}")


@app.route('/detail/<sha256>')
def get_detail(sha256):
    """
    Get sample details by SHA256 hash.

    Args:
        sha256: The SHA256 hash of the sample
    """
    try:
        if not validate_sha256(sha256):
            return api_error("Invalid SHA256 hash format", code=40000, http_status=400)

        query_result = db_ops.mysqlsha256s(sha256)
        if not query_result:
            return api_error("Sample not found", code=40400, http_status=404)

        query_result = convert_to_serializable(query_result)
        query_result_inner = query_result[0]
        query_result_dict = build_sample_dict(query_result_inner)

        logger.info(f"Detail retrieved for {sha256}")
        return api_success({'query_result': query_result_dict})

    except IndexError:
        logger.error(f"Sample not found in database: {sha256}")
        return api_error("Sample not found", code=40400, http_status=404)
    except Exception as e:
        logger.error(f"Error retrieving detail for {sha256}: {str(e)}")
        return api_error(f"Failed to retrieve sample details: {str(e)}")


@app.route('/download/<sha256>', methods=['GET'])
def download_file(sha256):
    """
    Download sample as password-protected ZIP.

    Args:
        sha256: The SHA256 hash of the sample to download

    Returns:
        Password-protected ZIP file (password: infected)
    """
    try:
        if not validate_sha256(sha256):
            return api_error("Invalid SHA256 hash format", code=40000, http_status=400)

        file_path = get_file_path_and_zip(sha256)
        if file_path is None:
            logger.warning(f"Sample file not found for download: {sha256}")
            return api_error("Sample file not found", code=40400, http_status=404)

        logger.info(f"Downloading sample: {sha256}")
        return send_from_directory(
            os.path.dirname(file_path),
            os.path.basename(file_path),
            as_attachment=True
        )

    except FileNotFoundError as e:
        logger.error(f"7zip not installed or file not found: {str(e)}")
        return api_error(f"Download failed: {str(e)}")
    except Exception as e:
        logger.error(f"Error downloading {sha256}: {str(e)}")
        return api_error(f"Download failed: {str(e)}")


@app.route('/query_sha256', methods=['POST'])
def query_virus_SHA256():
    """Query sample by SHA256 hash."""
    try:
        data = request.json
        if not data:
            return api_error("Request body is required", code=40000, http_status=400)

        sha256 = data.get('tableName')
        if not sha256:
            return api_error("SHA256 hash is required", code=40000, http_status=400)

        if not validate_sha256(sha256):
            return api_error("Invalid SHA256 hash format", code=40000, http_status=400)

        query_result = db_ops.mysqlsha256s(sha256)
        if not query_result:
            return api_error("Sample not found", code=40400, http_status=404)

        query_result = convert_to_serializable(query_result)
        query_result_inner = query_result[0]
        query_result_dict = build_sample_dict(query_result_inner)

        logger.info(f"SHA256 query result for {sha256}")
        return api_success({'query_sha256': query_result_dict})

    except IndexError:
        logger.error(f"Sample not found for SHA256: {sha256}")
        return api_error("Sample not found", code=40400, http_status=404)
    except pymysql.MySQLError as e:
        logger.error(f"Database error in SHA256 query: {str(e)}")
        return api_error(f"Database error: {str(e)}")
    except Exception as e:
        logger.error(f"Error in SHA256 query: {str(e)}")
        return api_error(f"Query failed: {str(e)}")


if __name__ == '__main__':
    app.run(host=HOST_IP, port=PORT, threaded=True)
